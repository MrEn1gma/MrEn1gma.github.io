[ { "title": "Coconut - ASCIS CTF 2022", "url": "/posts/Coconut-ASCIS-CTF-2022/", "categories": "CTF, RE", "tags": "Obfuscation, ascis", "date": "2022-10-19 20:00:00 +0700", "snippet": "Lời nói đầu Vòng loại giải Sinh Viên An Toàn Thông Tin ASEAN đã kết thúc vào ngày 15/10. Đó là ngày đáng nhớ của mình cũng như các bạn khác tham gia vào ngày hôm đó, team mình - th++ đã cố gắng giành được giải Khuyến Khích. Cảm xúc của mình lúc đó có buồn, có vui. Nhưng ít nhất mình cũng đã tận hưởng những ngày tháng cùng đám bạn tham gia SVATTT với tư cách là sinh viên năm cuối ĐH. Bài coconut mình đã không kịp giải ra vào thời điểm đó, nhưng mình đã cố gắng giải bài này và cuối cùng mình cũng đã hoàn thành. Trước khi đi vào phần writeup, mình xin cảm ơn em @mochi753 và @EaZyQ đã hỗ trợ anh giải ra được bài đó. Giới thiệu Given files: coconut.exe Category: Reversing Summary: Crackme được viết bằng c# và sử dụng kỹ thuật che giấu đi code thật (không rõ chi tiết cái technique đó), bằng việc decrypt toàn bộ các hàm bị obfuscation. Sau đó reverse lại cái Crypto đó, mình tìm được key của flag1, flag thứ 2 phụ thuộc vào stack frame để cho ra key đúng, từ đó mình tìm ra được flag còn lại.Tổng quanNhìn tổng quan toàn bộ các hàm của binary, dễ dàng nhận ra rằng tất cả các hàm đều bị obfuscated, ngoại trừ hàm coconut_10 là nơi lưu trữ các giá trị nhằm phục vụ cho việc deobfuscate sau khi crackme được thực thi.internal class Program{\t// Token: 0x06000017 RID: 23 RVA: 0x00002FF4 File Offset: 0x000011F4\tprivate static void Main(string[] args)\t{\t\tCoconut.coconut_10();\t\tstring text = Coconut.coconut_28();\t\tif (Coconut.coconut_25(Coconut.coconut_15(text)))\t\t{\t\t\tCoconut.coconut_46(text);\t\t}\t}}Phần Deobfuscate sẽ giải mã toàn bộ các hàm và tiếp tục phân tích.DeobfuscateMình lấy hàm coconut_28 làm ví dụ: hàm này sử dụng để giải mã cái hàm coconut_82, nhưng do hàm coconut_82 chưa được dnSpy nhận diện là 1 hàm, nên nó sẽ nhảy tới hàm coconut_25 để decode. Để ý là có coconut_meat28 và coconut_water28 được load vào.Hàm coconut_25:public static object coconut_25(InvalidProgramException e, object[] args, Dictionary&lt;uint, int&gt; m, byte[] b){\tint metadataToken = new StackTrace(e).GetFrame(0).GetMethod().MetadataToken;\tModule module = typeof(Program).Module;\tMethodInfo methodInfo = (MethodInfo)module.ResolveMethod(metadataToken);\tMethodBase methodBase = module.ResolveMethod(metadataToken);\tParameterInfo[] parameters = methodInfo.GetParameters();\tType[] array = new Type[parameters.Length];\tSignatureHelper localVarSigHelper = SignatureHelper.GetLocalVarSigHelper();\tfor (int i = 0; i &lt; array.Length; i++)\t{\t\tarray[i] = parameters[i].ParameterType;\t}\tType declaringType = methodBase.DeclaringType;\tDynamicMethod dynamicMethod = new DynamicMethod(\"\", methodInfo.ReturnType, array, declaringType, true);\tDynamicILInfo dynamicILInfo = dynamicMethod.GetDynamicILInfo();\tMethodBody methodBody = methodInfo.GetMethodBody();\tforeach (LocalVariableInfo localVariableInfo in methodBody.LocalVariables)\t{\t\tlocalVarSigHelper.AddArgument(localVariableInfo.LocalType);\t}\tbyte[] signature = localVarSigHelper.GetSignature();\tdynamicILInfo.SetLocalSignature(signature);\tforeach (KeyValuePair&lt;uint, int&gt; keyValuePair in m)\t{\t\tint value = keyValuePair.Value;\t\tuint key = keyValuePair.Key;\t\tint tokenFor;\t\tif (value &gt;= 1879048192 &amp;&amp; value &lt; 1879113727)\t\t{\t\t\ttokenFor = dynamicILInfo.GetTokenFor(module.ResolveString(value));\t\t}\t\telse\t\t{\t\t\tMemberInfo memberInfo = declaringType.Module.ResolveMember(value, null, null);\t\t\tif (memberInfo.GetType().Name == \"RtFieldInfo\")\t\t\t{\t\t\t\ttokenFor = dynamicILInfo.GetTokenFor(((FieldInfo)memberInfo).FieldHandle, ((TypeInfo)((FieldInfo)memberInfo).DeclaringType).TypeHandle);\t\t\t}\t\t\telse if (memberInfo.GetType().Name == \"RuntimeType\")\t\t\t{\t\t\t\ttokenFor = dynamicILInfo.GetTokenFor(((TypeInfo)memberInfo).TypeHandle);\t\t\t}\t\t\telse if (memberInfo.Name == \".ctor\" || memberInfo.Name == \".cctor\")\t\t\t{ tokenFor = dynamicILInfo.GetTokenFor(((ConstructorInfo)memberInfo).MethodHandle, ((TypeInfo)((ConstructorInfo)memberInfo).DeclaringType).TypeHandle);\t\t\t}\t\t\telse\t\t\t{\t\t\t\ttokenFor = dynamicILInfo.GetTokenFor(((MethodInfo)memberInfo).MethodHandle, ((TypeInfo)((MethodInfo)memberInfo).DeclaringType).TypeHandle);\t\t\t}\t\t}\t\tb[(int)key] = (byte)tokenFor;\t\tb[(int)(key + 1U)] = (byte)(tokenFor &gt;&gt; 8);\t\tb[(int)(key + 2U)] = (byte)(tokenFor &gt;&gt; 16);\t\tb[(int)(key + 3U)] = (byte)(tokenFor &gt;&gt; 24);\t}\tdynamicILInfo.SetCode(b, methodBody.MaxStackSize);\treturn dynamicMethod.Invoke(null, args);}MetadataToken thực hiện load token nhằm lấy data của hàm coconut_82, sau đó thực hiện vòng lặp để nạp vào các section và tiến hành giải mã các byte của hàm coconut_82, cuối cùng thực thi chúng bằng method dynamicMethod.Invoke(null, args). metataToken: Hàm giải mã:b[(int)key] = (byte)tokenFor;b[(int)(key + 1U)] = (byte)(tokenFor &gt;&gt; 8);b[(int)(key + 2U)] = (byte)(tokenFor &gt;&gt; 16);b[(int)(key + 3U)] = (byte)(tokenFor &gt;&gt; 24);Nhận xét: hàm coconut_25 chỉ thực hiện giải mã bằng cách dùng toán tử shift right lần lượt là 8, 16, 24, mình có thể viết script để thực hiện giải mã:def ASCIS_coconut_decrypt(meat, water): for i in range(len(meat)): water[meat[i][0]] = meat[i][1] &amp; 0xff water[meat[i][0] + 1] = (meat[i][1] &gt;&gt; 8) &amp; 0xff water[meat[i][0] + 2] = (meat[i][1] &gt;&gt; 16) &amp; 0xff water[meat[i][0] + 3] = (meat[i][1] &gt;&gt; 24) &amp; 0xff return waterSau đó sửa các byte dựa trên địa chỉ của water tương ứng với hàm cần giải mã, trong trường hợp ở đây là water28 có địa chỉ là 0x7bc + 21 với 21 là size của water28.NOTE: để tìm chính xác địa chỉ của water28, mình sử dụng chức năng Show Instructions in Hex Editor.Full script mình để ở đây: deobfuscate_coconutPhân tích coconut.exe (patched)Sau khi decrypt xong, hàm coconut_82 và các hàm khác đã được giải mã. Nhập key và read key. public static string coconut_82(){ Console.Write(\"Enter key: \"); return Console.ReadLine();} Hàm xử lý inputpublic static string coconut_51(string s){\treturn BitConverter.ToString(Encoding.Default.GetBytes(s)).Replace(\"-\", \"\");}Quan sát hàm coconut_51, mình nhận thấy nó thực hiện 2 bước để check. Đầu tiên chúng sẽ convert các ký tự ASCII sang chuỗi số thập lục phân và xoá các ký tự - để thành 1 chuỗi hexstring. Tiếp tục đi vào hàm coconut_52 để thực hiện check key. Hàm coconut_52:public static bool coconut_52(string i){\treturn BigInteger.Parse(i, NumberStyles.HexNumber) * Coconut.coconut_89(Coconut.water_01) % Coconut.coconut_89(Coconut.water_02) == Coconut.coconut_89(Coconut.water_03);}public static BigInteger coconut_98(byte[] b){\tstring text = \"\";\tforeach (byte b2 in b)\t{\t\tif (b2 &lt; 10)\t\t{\t\t\ttext += ((char)(b2 + 48)).ToString();\t\t}\t\telse\t\t{\t\t\ttext += ((char)(b2 + 87)).ToString();\t\t}\t}\treturn BigInteger.Parse(text, NumberStyles.HexNumber);}Quan sát hàm coconut_98, chúng sẽ load lần lượt các giá trị Coconut.water_01, Coconut.water_02, Coconut.water_03 để tính toán ra các số nguyên lớn và sau khi input được convert sang chuỗi hexstring, method BigInteger trong hàm coconut_52 prase chuỗi hexstring thành số nguyên lớn. Sau đó thực hiện tính toán để check key.Nhận xét: Một bài toán liên quan tới Crypto, tuy nhiên thì mình không đi sâu về phần giải thích mà chỉ đưa ra phần giải.-- PROBLEM --passwd * coconut_water01 % coconut_water02 = coconut_water03=&gt; passwd = (coconut_water03 * inverse(coconut_water01, coconut_water02)) % coconut_water02 Thực hiện bằng python scriptpasswd = long_to_bytes((ASCIS_coconut_52_BIGNUMBER(coconut_water03) * inverse(ASCIS_coconut_52_BIGNUMBER(coconut_water01), ASCIS_coconut_52_BIGNUMBER(coconut_water02))) % ASCIS_coconut_52_BIGNUMBER(coconut_water02))Chạy file script trên, mình đã tìm ra được key: Ytd_is_history_Tmr_is_a_mystery!. Lúc này mình thử test trên powershell thì ra được thông báo dưới đây:Tuy nhiên trong lúc chạy thì file PANDA.png đã được dump ra:Như vậy mình đã có được 1 phần của flag: ASCIS{7hat's_Why_7h3y_call_it. Tuy nhiên phần còn lại của flag thì mình chưa biết, vì cái thông báo trên powershell lúc nãy đã cho mình biết được nhiệm vụ tiếp theo phải bypass được đoạn đó để tìm ra flag còn lại.Bypass the TimePhân tích lại file sau khi đã deobfuscated, sau khi đã decrypt ra file PANDA.jpg bằng thuật toán AES, nó nhảy vào hàm coconut_06 và tới hàm coconut_60:public static void coconut_60(){\twhile (DateTime.Now.Year &lt; 3022)\t{\t\tConsole.WriteLine(\"Waiting for a thousand year.\");\t\tThread.Sleep(86400000);\t}\tCoconut.coconut_36();}Đoạn check chỉ kiểm tra năm hiện tại trên máy tính có lớn hơn 3022 hay không, ngược lại nó sẽ nhảy vào vòng lặp “vô tận”. Để pass nó, bạn đọc có thể edit lại method và sửa dấu &lt; thành &gt;. Lưu lại và chạy file đã patched.Lần này mình đã dump ra được file DRAGON_WARRIOR.png, nhưng có gì đó không đúng….Debug qua đoạn dump ra file DRAGON_WARRIOR.png cụ thể ở đây là hàm coconut_16, mình thấy nó in ra key: Void coconut_63()System.String coconut_16()Phân tích hàm coconut_61, nó đang lấy Frame dựa trên stackTrace để lấy tên hàm con thuộc coconut_61,trong trường hợp này là hàm coconut_61 và coconut_63. Cho nên mới có kết quả khi return cái key trên. Tuy nhiên, key đó không đúng vì lúc nãy mình đã chạy thử file patched trước đó.public static string coconut_61(){\tStackTrace stackTrace = new StackTrace();\treturn stackTrace.GetFrame(2).GetMethod().ToString() + stackTrace.GetFrame(1).GetMethod().ToString();}Vậy vấn đề ở đây là gì ?Quay trở lại hàm coconut_36, try-catch sẽ thực hiện nhảy vào hàm coconut_63, nếu như hàm đó không bị lỗi và ngược lại nó sẽ nhảy vào hàm coconut_25. Vấn đề là khi trace tới coconut_63 nó không bị lỗi bởi vì mình đã deobfuscate hàm đó rồi. Đó chính là mấu chốt của bài toán trên, vì vậy mình buộc phải trace vào hàm coconut_25 thì mới return về key đúng.Giải pháp:Chuyển số 3022 ra dạng hexadecimal ta được 0x0bce, tức là 206 và 11. Đồng thời mở file Coconut.exe ban đầu (chưa modified gì hết), ta lấy tất cả bytes của water06:Tìm số 206 và 11, mình thấy nó nằm trong mảng water06. Pattern đó chính là số 3022 thuộc đoạn while (DateTime.Now.Year &gt; 3022), mình có thể thay số 3022 thành số nào nhỏ hơn năm hiện tại trên máy (ở đây là năm 2022), ở đây mình sẽ dùng số 2019 tức là 227 07 dưới dạng bytearray. Sau đó patch 2 số đó vào vị trí của số 206 và 11. water06 sau khi được modified:Cuối cùng, chạy file sau khi sửa, ta đã thành công dump được file DRAGON_WARRIOR.png:Flag thứ 2: _Prrrres3nt!!!!}Ghép lại flag1 và flag2, ta được 1 flag hoàn chỉnh: ASCIS{7hat's_Why_7h3y_call_it_Prrrres3nt!!!!}Full script solve mình để ở đây: solveENDHết rồi =)))" }, { "title": "findtheflag.exe - defeating custom Self Modify with IDAPython", "url": "/posts/findtheflag-extremecoder/", "categories": "CTF, RE", "tags": "selfmodify, idapython, z3", "date": "2022-09-07 14:00:00 +0700", "snippet": "Lời nói đầuCrackme trên do mình tình cờ đọc blog của anh m4n0w4r về writeup có trên tut4you. Bài này tuy dùng kỹ thuật khá là cổ điển nhưng ít nhiều nó giúp mình có thêm cái nhìn rõ hơn về kỹ thuật Self Modify mà tác giả đã vận dụng rất sáng tạo.Giới thiệu Given files: findtheflag.exe Description: You need to find the flag which will print the good boy message, Everything is allowed. Category: Reversing Summary: Tác giả sử dụng kỹ thuật Self Modify nhằm mã hoá từng phần của instruction sang các bytecode. Bằng cách sử dụng IDAPython, mình sẽ khôi phục lại các instruction về ban đầu.Phân tích binaryPhân tích hàm main, mình nhận thấy rằng IDA chỉ nhận diện được tới đoạn popa instruction, còn khúc sau mình nhận thấy nó không giống với instruction thông thường, khả năng cao nó là các bytecodes đã bị mã hoá.Đặt breakpoint tại pusha (0x40103a) and popa (0x401055). Sau đó debug tới địa chỉ 0x401055, nhận thấy rằng 1 phần đầu của bytecode đã được giải mã bằng thuật toán XOR. Tuy nhiên hay nhìn địa chỉ 0x40125a tới địa chỉ 0x401275, mình thấy rằng nó gần giống với block trên và nó sử dụng key xor tận 2 lần. Điều đó có nghĩa là, nếu như mình trace từ block thứ nhất sang block tiếp theo, các bytecode sẽ được giữ nguyên bởi vì 2 lần mã hoá/giải mã đều sử dụng chung key. Để giải thích rõ ràng hơn, mình đã mô phỏng lại cách hoạt động của Crackme này: Gọi STAGE 1 là quá trình thực hiện 3 bước Giải mã -&gt; Thực thi code -&gt; Mã hoá của nhóm bytecodes thứ nhất (chú ý rằng bytecodes mà địa chỉ 0x401056 trở đi nó được chia thành từng nhóm nhỏ để thực hiện theo STAGE). Nếu mình debug tới STAGE thứ N, nghĩa là N - 1 STAGE trước đó đã bị modified về các bytecodes ban đầu, hiểu nôm na rằng chương trình ngăn chặn không cho mình xem được full mã giả.Chiến thuậtNhận xét: Đối với bài này, nếu luớt hết các bytecodes ở dưới, mình thấy có khá là nhiều, chưa kể mình cũng không biết chính xác Crackme này thực hiện bao nhiêu STAGE nên việc debug trong trong trường hợp này là không hiệu quả. Vì vậy sẽ thuận tiện hơn nếu như sử dụng IDAPython để decrypt các bytecodes trên. Vậy thì, để làm được điều này mình cần phải có những thông tin sau: Size của nhóm bytecodes: dựa vào pattern B9, tương ứng với mov ecx. Từ đó sử dụng hàm get_operand_value để lấy giá trị của operand thứ 1 cũng chính là giá trị của size bytecode. Key xor của bytecodes: dựa vào pattern 80 34 0E chính là xor. Cách lấy giá trị keyxor cũng làm tương tự như ở bước trên. Size của nhóm pusha tới popa: dễ dàng nhận thấy có 28 bytes. Bytecodes và địa chỉ tương ứng với các bytes: sau khi có size của nhóm bytecodes và Size của nhóm pusha tới popa thì việc tìm các bytecodes sẽ trở nên dễ dàng hơn. Để ý rằng, bytecodes bắt đầu từ địa chỉ 0x401056, mình sẽ tính được các bytecode kế tiếp bằng cách lấy địa chỉ đầu tiên của nhóm bytecodes + size của nhóm bytecodes + 56, với 56 là 28 bytes của nhóm pusha/popa + 28 bytes kế tiếp của nhóm pusha/popa đó.Sau đó dùng hàm ida_bytes.patch_bytes để thay thế bằng giá trị của bytecode xor với keyxor tương ứng và nop luôn các block có pusha tới popa.Tới giờ thực hiện rồi !!!Tìm các nhóm bytecodes:def getGroupOfBytes(list_size): start_addr = idaapi.inf_get_main() + 0x56 # start bytecodes list_bytes = [] list_addrs = [] for idx_size in list_size: list_addrs.append(start_addr) out = [i for i in ida_bytes.get_bytes(start_addr, idx_size)] list_bytes.append(out) start_addr = start_addr + idx_size + 56 return list_bytes, list_addrsTìm size của bytecode và keyxor:def search_list_pattern(startEA, endEA, pattern): list_addr = [] while(startEA &lt; endEA): out = find_binary(startEA, endEA, pattern, 16, SEARCH_DOWN) if((out not in list_addr) and (out != ida_idaapi.BADADDR) and (idc.get_operand_value(out, 1) &lt; 0xffff)): list_addr.append(out) startEA += 1 return list_addrdef getValueFromAddr(list_addr): out = [] out1 = [] for idx_addr in list_addr: out.append(idc.get_operand_value(idx_addr, 1)) for i in range(0, len(out), 2): # each stages do dec/enc at the same stage, dec/enc are used same size of bytes. So I remove one in each stages out1.append(out[i]) return out1list_size_of_bytecodes = getValueFromAddr(search_list_pattern(main_startEA, main_endEA, opcode_of_size_bytecodes))list_key_xor = getValueFromAddr(search_list_pattern(main_startEA, main_endEA, opcode_xor))Full script mình để ở đây: unpackerPhân tích file decrypted (unpackeeeer.exe)Sau khi chạy script xong, mình đã có được mã giả tương đối đẹp.Đối với mình thì mã giả trên chưa thật sự “đẹp” cho lắm, cho nên mình đã chỉnh lại cái size của char Buffer[4] thành char Buffer[31] (vì nhìn vào input ta thấy được hàm gets lấy tối đa là 31 bytes), lúc này mã giả trông đẹp hơn.Về tổng quan chương trình mới là 1 đống hệ phương trình tuyến tính, mình không mất quá nhiều thời gian để giải tay, trực tiếp quăng nó vô z3 solver và giải ra nghiệm và grep lại thành flag.Full script solve solve.py" } ]
